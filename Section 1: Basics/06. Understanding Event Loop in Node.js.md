### Topic 6: Understanding Event Loop in Node.js

The **Event Loop** is one of the most important concepts in Node.js. It is the core mechanism that makes Node.js non-blocking, asynchronous, and efficient. Node.js uses a single-threaded architecture, but it can handle many connections at once thanks to the event loop.

At a high level, when a Node.js program runs, it executes code on the main thread. If any part of the code includes tasks like reading a file, waiting for a timer, or making a network request, these tasks are offloaded to the Node.js APIs (backed by the libuv library). The event loop ensures that the main thread does not get blocked while waiting for these tasks to finish.

Let’s break it down with an example. Create a file called `eventLoopDemo.js` and add the following:

```js
console.log("Start");

setTimeout(() => {
  console.log("Timeout callback");
}, 0);

console.log("End");
```

When you run this using `node eventLoopDemo.js`, the output will be:

```
Start
End
Timeout callback
```

Even though `setTimeout` is set to `0` milliseconds, its callback is pushed to the event queue. The event loop waits for the main execution (synchronous part) to finish before handling queued tasks like this timeout. This behavior highlights how asynchronous code runs only after the main thread is done.

The event loop operates in **phases**, where each phase handles a different type of operation:

1. **Timers** – Executes callbacks from `setTimeout()` and `setInterval()`.
2. **Pending Callbacks** – Handles I/O callbacks that were deferred.
3. **Idle/Prepare** – Internal use.
4. **Poll** – Retrieves new I/O events; executes I/O-related callbacks.
5. **Check** – Executes `setImmediate()` callbacks.
6. **Close Callbacks** – Handles `close` events like when a socket is closed.

Another useful example is comparing `setImmediate()` vs `setTimeout()`:

```js
setImmediate(() => {
  console.log("Immediate");
});

setTimeout(() => {
  console.log("Timeout");
}, 0);
```

Although both are delayed, `setImmediate()` is queued to run in the “check” phase, after the poll phase, while `setTimeout()` runs in the timers phase. Their order may vary depending on execution timing.

Node.js also handles **I/O asynchronously** using the event loop. Consider this:

```js
const fs = require('fs');

fs.readFile('test.txt', 'utf8', (err, data) => {
  if (err) throw err;
  console.log("File read complete");
});

console.log("Reading file...");
```

Even though file reading might take time, the event loop lets the `console.log("Reading file...")` run immediately while the file is read in the background.

In summary, the event loop is what enables Node.js to perform non-blocking operations using a single thread. It handles asynchronous callbacks, manages different types of operations in phases, and ensures your app stays fast and responsive. Understanding the event loop is key to writing efficient Node.js code.
